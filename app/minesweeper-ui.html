<!DOCTYPE html>

<html>

<head>
	<title>Minesweeper</title>
	<meta charset="utf-8">
	<style>
		* {
			margin: 0;
		}
		html,
		body {
			width: 100%;
			height: 100%;
			overflow: hidden;
      background-color: var(--rlm-card-color);
		}
		canvas {
			display: block;
      padding-left: 0;
      padding-right: 0;
      margin-left: auto;
      margin-right: auto;
		}
	</style>
</head>


<script type="module">

import kaboom from "https://unpkg.com/kaboom/dist/kaboom.mjs";

/*const windowWidth = document.documentElement.clientWidth
const windowHeight = document.documentElement.clientHeight
const gameWidth = 700
const gameHeight = 700
const scaleX = windowWidth / gameWidth
const scaleY = windowHeight / gameHeight 
const scaleGame = Math.min(scaleX, scaleY)*/


async function getState() {
        const response = await fetch('/apps/minesweeper/state')
        return response.json()
    }
var state = await getState()
var width = state[0]
var height = state[1]
var mines = state[2]
var reveals = state[3]
var win = state[4]
var lose = state[5]
var grid = state[6]

async function post(tag, data) {
    const response = await fetch('/apps/minesweeper', {
        method: 'POST',
        body: JSON.stringify({[tag]: data})
    })

    if(tag == "new-game")
      location.reload()

    state = await response.json()
    width = await state[0]
    height = await state[1]
    mines = await state[2]
    reveals = await state[3]
    win = await state[4]
    lose = await state[5]
    grid = await state[6]

    await go("minesweeper")
}


function flagCount()
{
  var count = 0;
  for(var j = 0; j < height; j++) 
    for(var i = 0; i < width; i++) 
      if(grid[j*width + i][1] == 1)
        count += 1

  return count;
}

var flags = flagCount()

var topBuffer = 80
var sideBuffer = 0

var topGridBuffer = 14
var sideGridBuffer = 14
var bottomGridBuffer = sideGridBuffer

var gameHeight = 600

var tileSize = (gameHeight - topBuffer - bottomGridBuffer)/height
if(tileSize > 40)
  tileSize = 40
//var tileSize = 40

var tileSpace = tileSize + tileSize/8
var tileRadius = 0

var shadowDistance = 2
if(tileSize < 20)
  shadowDistance = 1

kaboom({
    width: width * tileSpace + sideGridBuffer * 2 + sideBuffer * 2,
    height: height * tileSpace + topGridBuffer + bottomGridBuffer + topBuffer,
    //width: 600,
    //height: 600,
    //scale: scaleGame,
    background: [255, 255, 255]
})

function drawGrid()
{

  onDraw(() => {

    var backColor = window.getComputedStyle(document.body).getPropertyValue('background-color')
    backColor = backColor.substring(4, backColor.length-1)
                        .replace(/ /g, '')
                        .split(',');

    drawRect({
      pos: vec2(0, 0),
      width: sideGridBuffer * 2 + tileSpace * width,
      height: topBuffer + topGridBuffer + bottomGridBuffer + tileSpace * height,
      color: rgb(backColor[0], backColor[1], backColor[2]),
    })

    var gridColor = rgb(238, 238, 238)
    if(backColor[0] < 200)
      gridColor = rgb(188, 198, 208)

    drawRect({
      pos: vec2(sideBuffer, topBuffer),
      width: sideGridBuffer * 2 + tileSpace * width,
      height: topGridBuffer + bottomGridBuffer + tileSpace * height,
      color: gridColor,
      radius: 6,
      outline: {width: 1, color: rgb(207, 207, 207)}
    })

    for(var j = 0; j < height; j++) 
      for(var i = 0; i < width; i++) 
        drawTile(sideBuffer + sideGridBuffer + i * tileSpace, topBuffer + topGridBuffer + j * tileSpace, grid[j*width + i], backColor)

    if(lose == 1)
    {
      drawText({
            text: "YOU LOSE",
            font: "apl386",
            pos: vec2((sideGridBuffer * 2 + tileSpace * width)/2, topBuffer/2),
            origin: "center",
            size: 50,
            color: rgb(0, 0, 150)
        })
    }
    else if(win == 1)
    {
      drawText({
            text: "YOU WIN!",
            font: "apl386",
            pos: vec2((sideGridBuffer * 2 + tileSpace * width)/2, topBuffer/2),
            origin: "center",
            size: 50,
            color: rgb(150, 0, 0)
        })
    }
    else
    {
      drawText({
            text: mines - flags,
            font: "apl386",
            pos: vec2((sideGridBuffer * 2 + tileSpace * width)/2, topBuffer/2),
            origin: "center",
            size: 50,
            color: rgb(150, 0, 0)
        })
    }


  })
}



function drawTile(x, y, tile, backColor)
{
    var revealed = tile[0]
    var flagged = tile[1]
    var mine = tile[2]
    var neighbors = tile[3]

    var textColor = rgb(0, 0, 0)
    
    var tileColor = rgb(207, 207, 207)
    var shadowColor = rgb(140, 140, 140)

    if(backColor[0] < 200)
    {
      tileColor = rgb(147, 157, 167)
      shadowColor = rgb(90, 90, 90)
    }

    if(mousePos().x > x && mousePos().x < x + tileSize && mousePos().y > y && mousePos().y < y + tileSize && lose == 0 && win == 0 && (isMouseDown() || isMouseDown("right")))
      tileColor = rgb(150, 150, 160)

    var shadowRect = {
        pos: vec2(x + shadowDistance, y + shadowDistance),
        width: tileSize,
        height: tileSize,
        color: shadowColor,
        radius: tileRadius
      }

    var tileRect = {
        pos: vec2(x, y),
        width: tileSize,
        height: tileSize,
        color: tileColor,
        radius: tileRadius
      }

    if(revealed == 0 || mine == 1)
    {
        if(tileSize > 10)
          drawRect(shadowRect)
        
        drawRect(tileRect)
    }
    if(revealed == 1 && neighbors > 0 && mine == 0)
    {
      switch(neighbors) {
        case 1:
          textColor = rgb(0, 0, 200)
          break;
        case 2:
          textColor = rgb(200, 0, 0)
          break;
        case 3:
          textColor = rgb(0, 200, 0)
          break;
        case 4:
          textColor = rgb(200, 0, 200)
          break;
        case 5:
          textColor = rgb(200, 100, 100)
          break;
        case 6:
          textColor = rgb(0, 0, 255)
          break;
        case 7:
          textColor = rgb(0, 255, 0)
          break;
        case 8:
          textColor = rgb(50, 50, 50)
          break;
        default:
          textColor = rgb(0, 0, 0)
      }
        
        drawText({
            text: neighbors,
            font: "apl386",
            pos: vec2(x + tileSize/2, y + tileSize/2),
            origin: "center",
            size: tileSize*.85,
            color: textColor
        })
    }

    if((lose == 1 || win == 1) && mine == 1)
    {
      drawMine(x, y)
    }
    if(flagged == 1 && revealed == 0 && lose == 0)
    {
      drawTriangle({
          p1: vec2(x + tileSize*.5, y + tileSize*.33),
          p2: vec2(x + tileSize *.33, y + tileSize*.66),
          p3: vec2(x + tileSize *.66, y + tileSize*.66),
          pos: vec2(0, 0),
          color: rgb(250, 0, 0),
      })
    }
}

function drawMine(x, y) {
  drawLine({
        p1: vec2(x + tileSize*.5, y + tileSize*.2),
        p2: vec2(x + tileSize*.5, y + tileSize*.8),
        width: 2,
        color: rgb(0, 0, 0),
    })
    drawLine({
        p1: vec2(x + tileSize*.2, y + tileSize*.5),
        p2: vec2(x + tileSize*.8, y + tileSize*.5),
        width: 2,
        color: rgb(0, 0, 0),
    })
    drawLine({
        p1: vec2(x + tileSize*.28, y + tileSize*.28),
        p2: vec2(x + tileSize*.72, y + tileSize*.72),
        width: 2,
        color: rgb(0, 0, 0),
    })
    drawLine({
        p1: vec2(x + tileSize*.28, y + tileSize*.72),
        p2: vec2(x + tileSize*.72, y + tileSize*.28),
        width: 2,
        color: rgb(0, 0, 0),
    })
  drawCircle({
        pos: vec2(x + tileSize*.5, y + tileSize*.5),
        radius: tileSize*.25,
        color: rgb(0, 0, 0),
      })

  drawCircle({
      pos: vec2(x + tileSize*.43, y + tileSize*.43),
      radius: tileSize*.05,
      color: rgb(255, 255, 255),
    })

    
}

function getTileFromMouse() {
  var x = Math.floor((mousePos().x - sideBuffer - sideGridBuffer)/tileSpace)
  var y = Math.floor((mousePos().y - topBuffer - topGridBuffer)/tileSpace)

  return [x, y]
}

function mouseOnGrid() {
  if(mousePos().x > (sideBuffer + sideGridBuffer) && mousePos().x < (sideBuffer*2 + sideGridBuffer*2 + width*tileSpace))
    if(mousePos().y > (topBuffer + topGridBuffer) && mousePos().y < (topBuffer + topGridBuffer + bottomGridBuffer + height*tileSpace))
      return 1
  
  return 0
}

function drawButtons()
{

  onDraw(() => {

    var backColor = window.getComputedStyle(document.body).getPropertyValue('background-color')
    backColor = backColor.substring(4, backColor.length-1)
                        .replace(/ /g, '')
                        .split(',');

    var tileColor = rgb(207, 207, 207)
    var shadowColor = rgb(140, 140, 140)

    if(backColor[0] < 200)
    {
      tileColor = rgb(147, 157, 167)
      shadowColor = rgb(90, 90, 90)
    }

    var y = topBuffer*.25

    var leftx = (sideGridBuffer * 2 + tileSpace * width)*.25 - tileSize/2

    if(mousePos().x > leftx && mousePos().x < leftx + tileSize && mousePos().y > y && mousePos().y < y + tileSize && isMouseDown())
      tileColor = rgb(150, 150, 160)

    drawRect({
        pos: vec2(leftx + 2, y + 2),
        width: tileSize,
        height: tileSize,
        color: shadowColor,
        radius: tileRadius
    })

    drawRect({
        pos: vec2(leftx, y),
        width: tileSize,
        height: tileSize,
        color: tileColor,
        radius: tileRadius
    })
    
    drawMine(leftx, y)

    var rightx = (sideGridBuffer * 2 + tileSpace * width)*.75 - tileSize/2

    if(mousePos().x > rightx && mousePos().x < rightx + tileSize && mousePos().y > y && mousePos().y < y + tileSize && isMouseDown())
      tileColor = rgb(150, 150, 160)
    else if(backColor[0] < 200)
      tileColor = rgb(147, 157, 167)
    else 
      tileColor = rgb(207, 207, 207)

    drawRect({
        pos: vec2(rightx + 2, y + 2),
        width: tileSize,
        height: tileSize,
        color: shadowColor,
        radius: tileRadius
    })

    drawRect({
        pos: vec2(rightx, y),
        width: tileSize,
        height: tileSize,
        color: tileColor,
        radius: tileRadius
      })

      drawTriangle({
          p1: vec2(rightx + tileSize*.5, y + tileSize*.33),
          p2: vec2(rightx + tileSize *.33, y + tileSize*.66),
          p3: vec2(rightx + tileSize *.66, y + tileSize*.66),
          pos: vec2(0, 0),
          color: rgb(250, 0, 0),
      })
        
    })
}


scene("minesweeper", () => {

    layers([
        "default",
    ], "default")

    drawGrid()
    drawButtons()

    onMouseRelease(() => {
      if(mouseOnGrid() && lose == 0 && win == 0)
        post("guess", getTileFromMouse())

      if(!mouseOnGrid())
      {
        if(mousePos().x > (sideGridBuffer * 2 + tileSpace * width)*.25 - tileSize/2 && mousePos().x < (sideGridBuffer * 2 + tileSpace * width)*.25 - tileSize/2 + tileSize && mousePos().y > topBuffer*.25 && mousePos().y < topBuffer*.25 + tileSize)
          go("newgame")
      }

    })

    onMouseRelease("right", () => {

      if(mouseOnGrid())
      {
        var pos = getTileFromMouse()

        if(grid[pos[1] * width + pos[0]][1] == 1)
          flags -= 1
        else
          flags += 1
      }

      if(mouseOnGrid() && lose == 0 && win == 0)
        post("flag", getTileFromMouse())
    })
    
})

go("minesweeper")


function addButton(txt, p, f) {

  console.log('added')
    const btn = add([
        text(txt, {font: "apl386", size: 20}),
        pos(p),
        area({ cursor: "default", }),
        scale(1),
        origin("center"),
    ])

    btn.onClick(f)

    btn.onUpdate(() => {
        if (btn.isHovering()) {
            const t = time() * 2
            btn.scale = vec2(1.1)
        } else {
            btn.scale = vec2(1)
            btn.color = rgb(150, 0, 0)
        }
    })
}



scene("newgame", () => {

  layers([
      "background",
      "default",
  ], "default")

  var backgrounddrawer = add([
        layer("background"),
        pos(0, 0)
  ])

  backgrounddrawer.onDraw(() => {
    
    var backColor = window.getComputedStyle(document.body).getPropertyValue('background-color')
    backColor = backColor.substring(4, backColor.length-1)
                        .replace(/ /g, '')
                        .split(',');

    drawRect({
      pos: vec2(0, 0),
      width: sideGridBuffer * 2 + tileSpace * width,
      height: topBuffer + topGridBuffer + bottomGridBuffer + tileSpace * height,
      color: rgb(backColor[0], backColor[1], backColor[2]),
    })
  })

  var midpoint = (sideGridBuffer * 2 + tileSpace * width)/2

  var triangleLeft = midpoint - 20
  var triangleWidth = 100

  var vals = [10, 10, 30]
  var maxs = [60, 30, 50]

  onDraw(() => {

    drawText({
        text: "WIDTH:",
        font: "apl386",
        pos: vec2(midpoint - 50, topBuffer),
        origin: "right",
        size: 20,
        color: rgb(0, 0, 150)
    })

    drawText({
        text: "HEIGHT:",
        font: "apl386",
        pos: vec2(midpoint - 50, topBuffer*2),
        origin: "right",
        size: 20,
        color: rgb(0, 0, 150)
    })

    drawText({
        text: "MINES:",
        font: "apl386",
        pos: vec2(midpoint - 50, topBuffer*3),
        origin: "right",
        size: 20,
        color: rgb(0, 0, 150)
    })

    for(var i = 0; i < 3; i++)
    {
      drawTriangle({
        p1: vec2(triangleLeft, topBuffer*(1+i) + 5),
        p2: vec2(triangleLeft + triangleWidth, topBuffer*(1+i) + 5),
        p3: vec2(triangleLeft + triangleWidth, topBuffer*(1+i) - 15),
        pos: vec2(0, 0),
        color: rgb(0, 0, 150)
      })

      drawRect({
        pos: vec2(triangleLeft + vals[i]*triangleWidth/maxs[i], topBuffer*(1+i) - 15),
        width: 5,
        height: 20,
        color: rgb(0, 0, 0),
      })

      drawText({
        text: vals[i],
        font: "apl386",
        pos: vec2(triangleLeft + triangleWidth + 10, topBuffer*(1+i)),
        origin: "left",
        size: 20,
        color: rgb(0, 0, 150)
      })
    }

  })

  addButton("GENERATE NEW BOARD", vec2(midpoint, topBuffer*3.5), () => post("new-game", [vals[0], vals[1], vals[2]]))
  addButton("RETURN TO GAME", vec2(midpoint, topBuffer*.5), () => go("minesweeper"))

  onMouseDown(() => {
      maxs[2] = Math.ceil(vals[0]*vals[1]*.5)
      if(vals[2] > maxs[2])
        vals[2] = maxs[2]

      if(mousePos().x >= triangleLeft && mousePos().x <= triangleLeft + triangleWidth)
      {
          for(var i = 0; i < 3; i++)
          {
              if(mousePos().y > topBuffer*(1+i) - 15 && mousePos().y < topBuffer*(1+i) + 5)
                vals[i] = Math.ceil((mousePos().x - triangleLeft)/triangleWidth*maxs[i])
                
              if(vals[0] < 5)
                vals[0] = 5
              if(vals[1] < 5)
                vals[1] = 5
              if(vals[2] < 1)
                vals[2] = 1

          }
      }
    })


})



</script>

</body>

</html>
