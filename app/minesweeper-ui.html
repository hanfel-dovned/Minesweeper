<!DOCTYPE html>

<html>

<head>
	<title>Minesweeper</title>
	<meta charset="utf-8">
	<style>
		* {
			margin: 0;
		}
		html,
		body {
			width: 100%;
			height: 100%;
			overflow: hidden;
      background-color: var(--rlm-card-color);
		}
		canvas {
			display: block;
      padding-left: 0;
      padding-right: 0;
      margin-left: auto;
      margin-right: auto;
		}
	</style>
</head>


<script type="module">

import kaboom from "https://unpkg.com/kaboom/dist/kaboom.mjs";

const windowWidth = document.documentElement.clientWidth
const windowHeight = document.documentElement.clientHeight
const gameWidth = 1200
const gameHeight = 700
const scaleX = windowWidth / gameWidth
const scaleY = windowHeight / gameHeight 
const scaleGame = Math.min(scaleX, scaleY)

async function getState() {
        const response = await fetch('/apps/minesweeper/state')
        return response.json()
    }
var state = await getState()
var width = state[0]
var height = state[1]
var mines = state[2]
var reveals = state[3]
var win = state[4]
var lose = state[5]
var grid = state[6]

async function post(tag, data) {
    const response = await fetch('/apps/minesweeper', {
        method: 'POST',
        body: JSON.stringify({[tag]: data})
    })

    if(tag == "new-game")
      location.reload()

    state = await response.json()
    width = await state[0]
    height = await state[1]
    mines = await state[2]
    reveals = await state[3]
    win = await state[4]
    lose = await state[5]
    grid = await state[6]

    await go("minesweeper")
}

var topBuffer = 80
var sideBuffer = 0

var topGridBuffer = 14
var sideGridBuffer = 14
var bottomGridBuffer = sideGridBuffer

var tileSize = 30
var tileSpace = tileSize + 5

kaboom({
    width: width * tileSpace + sideGridBuffer * 2 + sideBuffer * 2,
    height: height * tileSpace + topGridBuffer + bottomGridBuffer + topBuffer,
    //scale: scaleGame,
    background: [255, 255, 255]
})

function drawGrid()
{

  onDraw(() => {

    var gridColor = window.getComputedStyle(document.body).getPropertyValue('background-color')
    gridColor = gridColor.substring(4, gridColor.length-1)
                        .replace(/ /g, '')
                        .split(',');

    drawRect({
      pos: vec2(0, 0),
      width: sideGridBuffer * 2 + tileSpace * width,
      height: topBuffer + topGridBuffer + bottomGridBuffer + tileSpace * height,
      color: rgb(gridColor[0], gridColor[1], gridColor[2]),
    })

    drawRect({
      pos: vec2(sideBuffer, topBuffer),
      width: sideGridBuffer * 2 + tileSpace * width,
      height: topGridBuffer + bottomGridBuffer + tileSpace * height,
      color: rgb(230, 230, 230),
      radius: 6,
      outline: {width: 1, color: rgb(210, 210, 210)}
    })

    for(var j = 0; j < height; j++) 
      for(var i = 0; i < width; i++) 
        drawTile(sideBuffer + sideGridBuffer + i * tileSpace, topBuffer + topGridBuffer + j * tileSpace, grid[j*width + i])

    if(lose == 1)
    {
      drawText({
            text: "YOU LOSE",
            font: "apl386",
            pos: vec2((sideGridBuffer * 2 + tileSpace * width)/2, topBuffer/2),
            origin: "center",
            size: 50,
            color: rgb(0, 0, 150)
        })
    }
    if(win == 1)
    {
      drawText({
            text: "YOU WIN!",
            font: "apl386",
            pos: vec2((sideGridBuffer * 2 + tileSpace * width)/2, topBuffer/2),
            origin: "center",
            size: 50,
            color: rgb(150, 0, 0)
        })
    }

  })
}

function drawTile(x, y, tile)
{
    var revealed = tile[0]
    var flagged = tile[1]
    var mine = tile[2]
    var neighbors = tile[3]

    var textColor = rgb(0, 0, 0)
    
    var tileColor = rgb(200, 200, 200)
    if(mousePos().x > x && mousePos().x < x + tileSize && mousePos().y > y && mousePos().y < y + tileSize && lose == 0 && win == 0 && (isMouseDown() || isMouseDown("right")))
      tileColor = rgb(180, 180, 180)

    if(revealed == 0 || mine == 1)
    {
        drawRect({
          pos: vec2(x + 2, y + 2),
          width: tileSize,
          height: tileSize,
          color: rgb(70, 70, 70),
        })
        drawRect({
          pos: vec2(x, y),
          width: tileSize,
          height: tileSize,
          color: tileColor,
          //outline: {width: 1, color: rgb(0, 0, 0)}
        })
    }
    if(revealed == 1 && neighbors > 0 && mine == 0)
    {
      switch(neighbors) {
        case 1:
          textColor = rgb(0, 0, 200)
          break;
        case 2:
          textColor = rgb(200, 0, 0)
          break;
        case 3:
          textColor = rgb(0, 200, 0)
          break;
        case 4:
          textColor = rgb(200, 0, 200)
          break;
        case 5:
          textColor = rgb(200, 100, 100)
          break;
        case 6:
          textColor = rgb(0, 0, 255)
          break;
        case 7:
          textColor = rgb(0, 255, 0)
          break;
        case 8:
          textColor = rgb(50, 50, 50)
          break;
        default:
          textColor = rgb(0, 0, 0)
      }
        
        drawText({
            text: neighbors,
            font: "apl386",
            pos: vec2(x + tileSize/2, y + tileSize/2),
            origin: "center",
            size: tileSize*.85,
            color: textColor
        })
    }

    if((lose == 1 || win == 1) && mine == 1)
    {
      drawCircle({
        pos: vec2(x + tileSize*.5, y + tileSize*.5),
        radius: tileSize*.25,
        color: rgb(0, 0, 0),
      })
    }
    if(flagged == 1 && revealed == 0)
    {
      drawTriangle({
          p1: vec2(x + tileSize*.5, y + tileSize*.33),
          p2: vec2(x + tileSize *.33, y + tileSize*.66),
          p3: vec2(x + tileSize *.66, y + tileSize*.66),
          pos: vec2(0, 0),
          color: rgb(250, 0, 0),
      })
    }
}

function getTileFromMouse() {
  var x = Math.floor((mousePos().x - sideBuffer - sideGridBuffer)/tileSpace)
  var y = Math.floor((mousePos().y - topBuffer - topGridBuffer)/tileSpace)

  return [x, y]
}

function mouseOnGrid() {
  if(mousePos().x > (sideBuffer + sideGridBuffer) && mousePos().x < (sideBuffer*2 + sideGridBuffer*2 + width*tileSpace))
    if(mousePos().y > (topBuffer + topGridBuffer) && mousePos().y < (topBuffer + topGridBuffer + bottomGridBuffer + height*tileSpace))
      return 1
  
  return 0
}


scene("minesweeper", () => {

    layers([
        "default",
    ], "default")

    drawGrid()

    onMouseRelease(() => {
      if(mouseOnGrid() && lose == 0 && win == 0)
        post("guess", getTileFromMouse())
    })
    onMouseRelease("right", () => {
      

      if(mouseOnGrid() && lose == 0 && win == 0)
        post("flag", getTileFromMouse())
    })
    
    onKeyPress("space", () => {
		  post("new-game", [20, 20, 10])
	  })
})

go("minesweeper")


</script>

</body>

</html>
