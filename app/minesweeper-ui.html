<!DOCTYPE html>

<html>

<head>
	<title>Minesweeper</title>
	<meta charset="utf-8">
	<style>
		* {
			margin: 0;
		}
		html,
		body {
			width: 100%;
			height: 100%;
			overflow: hidden;
      background-color: var(--rlm-card-color);
		}
		canvas {
			display: block;
      padding-left: 0;
      padding-right: 0;
      margin-left: auto;
      margin-right: auto;
		}
	</style>
</head>


<script type="module">

import kaboom from "https://unpkg.com/kaboom/dist/kaboom.mjs";

/*const windowWidth = document.documentElement.clientWidth
const windowHeight = document.documentElement.clientHeight
const gameWidth = 700
const gameHeight = 700
const scaleX = windowWidth / gameWidth
const scaleY = windowHeight / gameHeight 
const scaleGame = Math.min(scaleX, scaleY)*/

async function getState() {
        const response = await fetch('/apps/minesweeper/state')
        return response.json()
    }
var state = await getState()
var width = state[0]
var height = state[1]
var mines = state[2]
var reveals = state[3]
var win = state[4]
var lose = state[5]
var grid = state[6]

async function post(tag, data) {
    const response = await fetch('/apps/minesweeper', {
        method: 'POST',
        body: JSON.stringify({[tag]: data})
    })

    if(tag == "new-game")
      location.reload()

    state = await response.json()
    width = await state[0]
    height = await state[1]
    mines = await state[2]
    reveals = await state[3]
    win = await state[4]
    lose = await state[5]
    grid = await state[6]

    await go("minesweeper")
}

var topBuffer = 80
var sideBuffer = 0

var topGridBuffer = 14
var sideGridBuffer = 14
var bottomGridBuffer = sideGridBuffer

var gameHeight = 600

var tileSize = (gameHeight - topBuffer - bottomGridBuffer)/height
//var tileSize = 40

var tileSpace = tileSize + tileSize/8
var tileRadius = 0

var shadowDistance = 2
if(tileSize < 20)
  shadowDistance = 1

kaboom({
    width: width * tileSpace + sideGridBuffer * 2 + sideBuffer * 2,
    height: height * tileSpace + topGridBuffer + bottomGridBuffer + topBuffer,
    //scale: scaleGame,
    background: [255, 255, 255]
})

function drawGrid()
{

  onDraw(() => {

    var backColor = window.getComputedStyle(document.body).getPropertyValue('background-color')
    backColor = backColor.substring(4, backColor.length-1)
                        .replace(/ /g, '')
                        .split(',');

    drawRect({
      pos: vec2(0, 0),
      width: sideGridBuffer * 2 + tileSpace * width,
      height: topBuffer + topGridBuffer + bottomGridBuffer + tileSpace * height,
      color: rgb(backColor[0], backColor[1], backColor[2]),
    })

    var gridColor = rgb(238, 238, 238)
    if(backColor[0] < 200)
      gridColor = rgb(188, 198, 208)

    drawRect({
      pos: vec2(sideBuffer, topBuffer),
      width: sideGridBuffer * 2 + tileSpace * width,
      height: topGridBuffer + bottomGridBuffer + tileSpace * height,
      color: gridColor,
      radius: 6,
      outline: {width: 1, color: rgb(207, 207, 207)}
    })

    for(var j = 0; j < height; j++) 
      for(var i = 0; i < width; i++) 
        drawTile(sideBuffer + sideGridBuffer + i * tileSpace, topBuffer + topGridBuffer + j * tileSpace, grid[j*width + i], backColor)

    if(lose == 1)
    {
      drawText({
            text: "YOU LOSE",
            font: "apl386",
            pos: vec2((sideGridBuffer * 2 + tileSpace * width)/2, topBuffer/2),
            origin: "center",
            size: 50,
            color: rgb(0, 0, 150)
        })
    }
    if(win == 1)
    {
      drawText({
            text: "YOU WIN!",
            font: "apl386",
            pos: vec2((sideGridBuffer * 2 + tileSpace * width)/2, topBuffer/2),
            origin: "center",
            size: 50,
            color: rgb(150, 0, 0)
        })
    }

  })
}

function drawTile(x, y, tile, backColor)
{
    var revealed = tile[0]
    var flagged = tile[1]
    var mine = tile[2]
    var neighbors = tile[3]

    var textColor = rgb(0, 0, 0)
    
    var tileColor = rgb(207, 207, 207)
    var shadowColor = rgb(140, 140, 140)

    if(backColor[0] < 200)
    {
      tileColor = rgb(147, 157, 167)
      shadowColor = rgb(90, 90, 90)
    }

    if(mousePos().x > x && mousePos().x < x + tileSize && mousePos().y > y && mousePos().y < y + tileSize && lose == 0 && win == 0 && (isMouseDown() || isMouseDown("right")))
      tileColor = rgb(150, 150, 160)

    var shadowRect = {
        pos: vec2(x + shadowDistance, y + shadowDistance),
        width: tileSize,
        height: tileSize,
        color: shadowColor,
        radius: tileRadius
      }

    var tileRect = {
        pos: vec2(x, y),
        width: tileSize,
        height: tileSize,
        color: tileColor,
        radius: tileRadius
      }

    if(revealed == 0 || mine == 1)
    {
        if(tileSize > 10)
          drawRect(shadowRect)
        
        drawRect(tileRect)
    }
    if(revealed == 1 && neighbors > 0 && mine == 0)
    {
      switch(neighbors) {
        case 1:
          textColor = rgb(0, 0, 200)
          break;
        case 2:
          textColor = rgb(200, 0, 0)
          break;
        case 3:
          textColor = rgb(0, 200, 0)
          break;
        case 4:
          textColor = rgb(200, 0, 200)
          break;
        case 5:
          textColor = rgb(200, 100, 100)
          break;
        case 6:
          textColor = rgb(0, 0, 255)
          break;
        case 7:
          textColor = rgb(0, 255, 0)
          break;
        case 8:
          textColor = rgb(50, 50, 50)
          break;
        default:
          textColor = rgb(0, 0, 0)
      }
        
        drawText({
            text: neighbors,
            font: "apl386",
            pos: vec2(x + tileSize/2, y + tileSize/2),
            origin: "center",
            size: tileSize*.85,
            color: textColor
        })
    }

    if((lose == 1 || win == 1) && mine == 1)
    {
      drawMine(x, y)
    }
    if(flagged == 1 && revealed == 0 && lose == 0)
    {
      drawTriangle({
          p1: vec2(x + tileSize*.5, y + tileSize*.33),
          p2: vec2(x + tileSize *.33, y + tileSize*.66),
          p3: vec2(x + tileSize *.66, y + tileSize*.66),
          pos: vec2(0, 0),
          color: rgb(250, 0, 0),
      })
    }
}

function drawMine(x, y) {
  drawLine({
        p1: vec2(x + tileSize*.5, y + tileSize*.2),
        p2: vec2(x + tileSize*.5, y + tileSize*.8),
        width: 2,
        color: rgb(0, 0, 0),
    })
    drawLine({
        p1: vec2(x + tileSize*.2, y + tileSize*.5),
        p2: vec2(x + tileSize*.8, y + tileSize*.5),
        width: 2,
        color: rgb(0, 0, 0),
    })
    drawLine({
        p1: vec2(x + tileSize*.28, y + tileSize*.28),
        p2: vec2(x + tileSize*.72, y + tileSize*.72),
        width: 2,
        color: rgb(0, 0, 0),
    })
    drawLine({
        p1: vec2(x + tileSize*.28, y + tileSize*.72),
        p2: vec2(x + tileSize*.72, y + tileSize*.28),
        width: 2,
        color: rgb(0, 0, 0),
    })
  drawCircle({
        pos: vec2(x + tileSize*.5, y + tileSize*.5),
        radius: tileSize*.25,
        color: rgb(0, 0, 0),
      })

  drawCircle({
      pos: vec2(x + tileSize*.43, y + tileSize*.43),
      radius: tileSize*.05,
      color: rgb(255, 255, 255),
    })

    
}

function getTileFromMouse() {
  var x = Math.floor((mousePos().x - sideBuffer - sideGridBuffer)/tileSpace)
  var y = Math.floor((mousePos().y - topBuffer - topGridBuffer)/tileSpace)

  return [x, y]
}

function mouseOnGrid() {
  if(mousePos().x > (sideBuffer + sideGridBuffer) && mousePos().x < (sideBuffer*2 + sideGridBuffer*2 + width*tileSpace))
    if(mousePos().y > (topBuffer + topGridBuffer) && mousePos().y < (topBuffer + topGridBuffer + bottomGridBuffer + height*tileSpace))
      return 1
  
  return 0
}


scene("minesweeper", () => {

    layers([
        "default",
    ], "default")

    drawGrid()

    onMouseRelease(() => {
      if(mouseOnGrid() && lose == 0 && win == 0)
        post("guess", getTileFromMouse())
    })
    onMouseRelease("right", () => {
      

      if(mouseOnGrid() && lose == 0 && win == 0)
        post("flag", getTileFromMouse())
    })
    
    onKeyPress("space", () => {
		  post("new-game", [20, 15, 80])
	  })
})

go("minesweeper")


</script>

</body>

</html>
